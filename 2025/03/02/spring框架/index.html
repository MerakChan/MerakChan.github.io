<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Spring Framework一、基本介绍模块如下： Spring 主要通过 IoC（控制反转） 和 AOP（面向切面编程） 解决了企业级开发中的复杂性，提高了开发效率。  二、Spring IoC什么是 IOC？IOC（Inversion of Control，控制反转）设计思想或模式 是 Spring 的核心概念，指 对象的创建和依赖管理交给 Spring 容器，而不是由程序手动管理。 IO">
<meta property="og:type" content="article">
<meta property="og:title" content="spring框架">
<meta property="og:url" content="http://example.com/2025/03/02/spring%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Merak Chan的技术博客">
<meta property="og:description" content="Spring Framework一、基本介绍模块如下： Spring 主要通过 IoC（控制反转） 和 AOP（面向切面编程） 解决了企业级开发中的复杂性，提高了开发效率。  二、Spring IoC什么是 IOC？IOC（Inversion of Control，控制反转）设计思想或模式 是 Spring 的核心概念，指 对象的创建和依赖管理交给 Spring 容器，而不是由程序手动管理。 IO">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MerakChan/pic/img/SpringFramework.png">
<meta property="og:image" content="attachment:1e5ec313-bf01-4da3-a1e0-e10b09d15c26:image.png">
<meta property="article:published_time" content="2025-03-02T06:24:32.000Z">
<meta property="article:modified_time" content="2025-03-04T06:43:59.838Z">
<meta property="article:author" content="Merak Chan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MerakChan/pic/img/SpringFramework.png">


<link rel="canonical" href="http://example.com/2025/03/02/spring%E6%A1%86%E6%9E%B6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/03/02/spring%E6%A1%86%E6%9E%B6/","path":"2025/03/02/spring框架/","title":"spring框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>spring框架 | Merak Chan的技术博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Merak Chan的技术博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Framework"><span class="nav-number">1.</span> <span class="nav-text">Spring Framework</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">一、基本介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Spring-IoC"><span class="nav-number">3.</span> <span class="nav-text">二、Spring IoC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-IOC%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">什么是 IOC？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">IOC 的核心机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC-%E5%AE%B9%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">IOC 容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">依赖注入（DI）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">3.4.1.</span> <span class="nav-text">（1）构造方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">3.4.2.</span> <span class="nav-text">（2）Setter 方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5"><span class="nav-number">3.4.3.</span> <span class="nav-text">（3）字段注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.</span> <span class="nav-text">IoC常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Component%E5%92%8C-Bean%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.5.1.</span> <span class="nav-text">@Component和@Bean的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired%E5%92%8C-Resource%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.5.2.</span> <span class="nav-text">@Autowired和@Resource区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.5.3.</span> <span class="nav-text">@注入Bean的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.5.4.</span> <span class="nav-text">@Bean的作用域有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.5.5.</span> <span class="nav-text">@Bean的生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Spring-AOP"><span class="nav-number">4.</span> <span class="nav-text">三、Spring AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AOP%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">什么是 AOP？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">AOP 相关术语？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.3.</span> <span class="nav-text">AOP 使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2"><span class="nav-number">4.3.1.</span> <span class="nav-text">（1）定义切面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">（2）切点表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.3.3.</span> <span class="nav-text">（3）通知类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.4.</span> <span class="nav-text">AOP常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP-%E5%92%8C-AspectJ-AOP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.4.1.</span> <span class="nav-text">Spring AOP 和 AspectJ AOP的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP%E5%B8%B8%E8%A7%81%E9%80%9A%E7%9F%A5%E7%B1%BB%EF%BC%9A"><span class="nav-number">4.4.2.</span> <span class="nav-text">AOP常见通知类：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">四、Spring 事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">5.0.1.</span> <span class="nav-text">简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">事务的核心概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">Spring 事务的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">5.2.1.</span> <span class="nav-text">（1）声明式事务管理（推荐）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E7%81%B5%E6%B4%BB%E4%BD%86%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">5.2.2.</span> <span class="nav-text">（2）编程式事务管理（灵活但不推荐）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">5.3.</span> <span class="nav-text">Spring 事务常见问题及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.1.</span> <span class="nav-text">（1）事务失效问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.2.</span> <span class="nav-text">（2）事务回滚问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.3.</span> <span class="nav-text">（3）多数据源事务问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8B%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.4.</span> <span class="nav-text">（4）事务超时问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Spring-MVC"><span class="nav-number">6.</span> <span class="nav-text">五、Spring MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC%E5%BC%80%E5%8F%91"><span class="nav-number">6.1.</span> <span class="nav-text">MVC开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Model-1-%E6%97%B6%E4%BB%A3"><span class="nav-number">6.1.1.</span> <span class="nav-text">Model 1 时代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Model-2-%E6%97%B6%E4%BB%A3"><span class="nav-number">6.1.2.</span> <span class="nav-text">Model 2 时代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-MVC-%E6%97%B6%E4%BB%A3"><span class="nav-number">6.1.3.</span> <span class="nav-text">Spring MVC 时代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.2.</span> <span class="nav-text">SpringMVC核心组件及工作原理简单介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Spring-Security"><span class="nav-number">7.</span> <span class="nav-text">六、Spring Security</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">7.0.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="nav-number">7.0.2.</span> <span class="nav-text">核心技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.0.3.</span> <span class="nav-text">常见应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Security-%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%E4%BC%BC%E6%8A%80%E6%9C%AF"><span class="nav-number">7.0.4.</span> <span class="nav-text">Spring Security 相关的类似技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81Spring-Data-JPA"><span class="nav-number">8.</span> <span class="nav-text">七、Spring Data JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">8.0.1.</span> <span class="nav-text">简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-number">8.1.</span> <span class="nav-text">核心特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">8.2.</span> <span class="nav-text">常见应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-number">8.3.</span> <span class="nav-text">其他相似的技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Data-JPA-%E4%B8%8E-MyBatis-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.4.</span> <span class="nav-text">Spring Data JPA 与 MyBatis 的区别</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Merak Chan</p>
  <div class="site-description" itemprop="description">Stay Gold, Pony Boy!!!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/02/spring%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Merak Chan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Merak Chan的技术博客">
      <meta itemprop="description" content="Stay Gold, Pony Boy!!!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="spring框架 | Merak Chan的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-02 14:24:32" itemprop="dateCreated datePublished" datetime="2025-03-02T14:24:32+08:00">2025-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-04 14:43:59" itemprop="dateModified" datetime="2025-03-04T14:43:59+08:00">2025-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E6%A0%B8%E5%BF%83%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java核心开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h1><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>模块如下：<br><img src="https://cdn.jsdelivr.net/gh/MerakChan/pic/img/SpringFramework.png"></p>
<p>Spring 主要通过 <strong>IoC（控制反转）</strong> 和 <strong>AOP（面向切面编程）</strong> 解决了企业级开发中的复杂性，提高了开发效率。</p>
<hr>
<h1 id="二、Spring-IoC"><a href="#二、Spring-IoC" class="headerlink" title="二、Spring IoC"></a>二、Spring IoC</h1><h2 id="什么是-IOC？"><a href="#什么是-IOC？" class="headerlink" title="什么是 IOC？"></a><strong>什么是 IOC？</strong></h2><p><strong>IOC（Inversion of Control，控制反转）设计思想或模式</strong> 是 Spring 的核心概念，指 <strong>对象的创建和依赖管理交给 Spring 容器，而不是由程序手动管理</strong>。</p>
<h2 id="IOC-的核心机制"><a href="#IOC-的核心机制" class="headerlink" title="IOC 的核心机制"></a><strong>IOC 的核心机制</strong></h2><ul>
<li><strong>依赖注入（DI, Dependency Injection）</strong>：通过 <strong>构造方法、Setter 方法、注解</strong> 自动注入依赖对象。</li>
<li><strong>Bean 管理</strong>：Spring 容器通过 <code>ApplicationContext</code> 统一管理 Bean 的创建、初始化、销毁。</li>
</ul>
<hr>
<h2 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a><strong>IOC 容器</strong></h2><p>Spring 主要提供两种 IOC 容器：</p>
<ol>
<li><strong>BeanFactory</strong>（底层容器，懒加载，轻量级）：<ul>
<li>适用于资源有限的环境，例如 IoT 设备。</li>
<li>使用 <code>ClassPathXmlApplicationContext</code> 或 <code>FileSystemXmlApplicationContext</code> 进行 XML 配置。</li>
</ul>
</li>
<li><strong>ApplicationContext</strong>（高级容器，默认预加载 Bean）：<ul>
<li><code>AnnotationConfigApplicationContext</code>（基于 Java 配置）</li>
<li><code>ClassPathXmlApplicationContext</code>（基于 XML）</li>
<li><code>WebApplicationContext</code>（适用于 Web 环境）</li>
</ul>
</li>
</ol>
<p><strong>示例：基于 Java 配置的 IOC</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a><strong>依赖注入（DI）</strong></h2><p>Spring 提供了三种依赖注入方式：</p>
<h3 id="（1）构造方法注入"><a href="#（1）构造方法注入" class="headerlink" title="（1）构造方法注入"></a><strong>（1）构造方法注入</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）Setter-方法注入"><a href="#（2）Setter-方法注入" class="headerlink" title="（2）Setter 方法注入"></a><strong>（2）Setter 方法注入</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）字段注入"><a href="#（3）字段注入" class="headerlink" title="（3）字段注入"></a><strong>（3）字段注入</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐使用构造方法注入，避免循环依赖问题。</p>
</blockquote>
<h2 id="IoC常见问题"><a href="#IoC常见问题" class="headerlink" title="IoC常见问题"></a>IoC常见问题</h2><h3 id="Component和-Bean的区别是什么？"><a href="#Component和-Bean的区别是什么？" class="headerlink" title="@Component和@Bean的区别是什么？"></a>@Component和@Bean的区别是什么？</h3><ul>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ul>
<hr>
<h3 id="Autowired和-Resource区别？"><a href="#Autowired和-Resource区别？" class="headerlink" title="@Autowired和@Resource区别？"></a><strong>@Autowired和@Resource区别？</strong></h3><ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li>
<li><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>
</ul>
<hr>
<h3 id="注入Bean的方式"><a href="#注入Bean的方式" class="headerlink" title="@注入Bean的方式"></a><strong>@注入Bean的方式</strong></h3><p>依赖注入 (Dependency Injection, DI) 的常见方式：</p>
<ol>
<li>构造函数注入：通过类的构造函数来注入依赖项。</li>
<li>Setter 注入：通过类的 Setter 方法来注入依赖项。</li>
<li>Field（字段） 注入：直接在类的字段上使用注解（如 <code>@Autowired</code> 或 <code>@Resource</code>）来注入依赖项。</li>
</ol>
<p><strong>Spring 官方推荐构造函数注入</strong>，这种注入方式的优势如下：</p>
<ol>
<li>依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。</li>
<li>不可变性：有助于创建不可变对象，提高了线程安全性。</li>
<li>初始化保证：组件在使用前已完全初始化，减少了潜在的错误。</li>
<li>测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。</li>
</ol>
<p>构造函数注入适合处理<strong>必需的依赖项</strong>，而 <strong>Setter 注入</strong> 则更适合<strong>可选的依赖项</strong>，这些依赖项可以有默认值或在对象生命周期中动态设置。虽然 <code>@Autowired</code> 可以用于 Setter 方法来处理必需的依赖项，但构造函数注入仍然是更好的选择。</p>
<p>在某些情况下（例如第三方类不提供 Setter 方法），构造函数注入可能是<strong>唯一的选择</strong>。</p>
<hr>
<h3 id="Bean的作用域有哪些？"><a href="#Bean的作用域有哪些？" class="headerlink" title="@Bean的作用域有哪些？"></a>@Bean的作用域有哪些？</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<hr>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="@Bean的生命周期"></a>@Bean的生命周期</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<hr>
<h1 id="三、Spring-AOP"><a href="#三、Spring-AOP" class="headerlink" title="三、Spring AOP"></a>三、Spring AOP</h1><h2 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a><strong>什么是 AOP？</strong></h2><p><strong>AOP（Aspect-Oriented Programming）</strong> 是面向切面编程的一种思想，用于 <strong>在不修改原代码的情况下增加额外功能</strong>，例如 <strong>日志记录、事务管理、权限控制</strong> 等。</p>
<p><strong>Spring AOP 主要使用代理模式实现</strong>：</p>
<ul>
<li><strong>JDK 动态代理（基于接口）</strong></li>
<li><strong>CGLIB 动态代理（基于子类继承）</strong></li>
</ul>
<hr>
<h2 id="AOP-相关术语？"><a href="#AOP-相关术语？" class="headerlink" title="AOP 相关术语？"></a><strong>AOP 相关术语？</strong></h2><ul>
<li><strong>切面（Aspect）</strong>：封装多个通知的逻辑模块，如日志、事务。</li>
<li><strong>通知（Advice）</strong>：额外逻辑，如 <code>@Before</code>、<code>@After</code>。</li>
<li><strong>切点（Pointcut）</strong>：定义在哪些方法上应用 AOP。</li>
<li><strong>连接点（JoinPoint）</strong>：具体执行的方法。</li>
<li><strong>目标对象（Target）</strong>：被代理的对象。</li>
<li><strong>代理（Proxy）</strong>：AOP 生成的代理对象。</li>
</ul>
<hr>
<h2 id="AOP-使用示例"><a href="#AOP-使用示例" class="headerlink" title="AOP 使用示例"></a><strong>AOP 使用示例</strong></h2><h3 id="（1）定义切面"><a href="#（1）定义切面" class="headerlink" title="（1）定义切面"></a><strong>（1）定义切面</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行方法: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）切点表达式"><a href="#（2）切点表达式" class="headerlink" title="（2）切点表达式"></a><strong>（2）切点表达式</strong></h3><p>常见的切点表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有 service 包下的类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethods</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）通知类型"><a href="#（3）通知类型" class="headerlink" title="（3）通知类型"></a><strong>（3）通知类型</strong></h3><p>Spring 提供多种 AOP 通知类型：</p>
<ul>
<li>**<code>@Before</code>**（方法执行前）</li>
<li>**<code>@After</code>**（方法执行后）</li>
<li>**<code>@Around</code>**（环绕增强）</li>
<li>**<code>@AfterReturning</code>**（方法正常返回）</li>
<li>**<code>@AfterThrowing</code>**（方法抛出异常）</li>
</ul>
<p><strong>使用 <code>@Around</code> 计算方法执行时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">measureExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; 方法执行时间: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP常见问题"><a href="#AOP常见问题" class="headerlink" title="AOP常见问题"></a>AOP常见问题</h2><h3 id="Spring-AOP-和-AspectJ-AOP的区别？"><a href="#Spring-AOP-和-AspectJ-AOP的区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP的区别？"></a><strong>Spring AOP 和 AspectJ AOP的区别？</strong></h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多</p>
<h3 id="AOP常见通知类："><a href="#AOP常见通知类：" class="headerlink" title="AOP常见通知类："></a>AOP常见通知类：</h3><ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<h1 id="四、Spring-事务管理"><a href="#四、Spring-事务管理" class="headerlink" title="四、Spring 事务管理"></a><strong>四、Spring 事务管理</strong></h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Spring 事务管理提供了一种 <strong>声明式（Declarative）</strong> 和 <strong>编程式（Programmatic）</strong> 方式来管理数据库事务，确保数据一致性，防止 <strong>脏读、不可重复读、幻读</strong> 等问题。</p>
<hr>
<h2 id="事务的核心概念"><a href="#事务的核心概念" class="headerlink" title="事务的核心概念"></a><strong>事务的核心概念</strong></h2><p>Spring 的事务管理基于 <strong>数据库事务 ACID（原子性、一致性、隔离性、持久性）</strong> 特性，核心概念如下：</p>
<ol>
<li><p><strong>事务传播（Propagation）</strong></p>
<p> Spring 定义了 7 种事务传播机制，控制方法在事务中的行为，例如：</p>
<ul>
<li><code>REQUIRED</code>（默认）：如果当前存在事务，使用当前事务；否则新建事务。</li>
<li><code>REQUIRES_NEW</code>：总是新建事务，暂停当前事务（如果存在）。</li>
<li><code>SUPPORTS</code>：如果有事务就加入，没有事务就以非事务方式执行。</li>
</ul>
</li>
<li><p><strong>事务隔离级别（Isolation Level）</strong></p>
<p> 影响多个事务并发访问时的数据可见性，常见隔离级别：</p>
<ul>
<li><code>READ_UNCOMMITTED</code>（读取未提交数据，可能导致脏读）</li>
<li><code>READ_COMMITTED</code>（读取已提交数据，防止脏读，但可能有不可重复读）</li>
<li><code>REPEATABLE_READ</code>（防止不可重复读，但可能有幻读）</li>
<li><code>SERIALIZABLE</code>（最高隔离级别，避免所有问题，但性能最低）</li>
</ul>
</li>
<li><p><strong>事务回滚机制（Rollback Rules）</strong></p>
<ul>
<li><strong>默认情况</strong>：Spring 事务只会在 <strong>运行时异常（<code>RuntimeException</code>）</strong> 或 <strong><code>Error</code></strong> 发生时回滚，<strong>受检异常（<code>CheckedException</code>）不会触发回滚</strong>。</li>
<li><strong>自定义回滚</strong>：可以通过 <code>@Transactional(rollbackFor = Exception.class)</code> 指定回滚的异常类型。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Spring-事务的实现方式"><a href="#Spring-事务的实现方式" class="headerlink" title="Spring 事务的实现方式"></a><strong>Spring 事务的实现方式</strong></h2><h3 id="（1）声明式事务管理（推荐）"><a href="#（1）声明式事务管理（推荐）" class="headerlink" title="（1）声明式事务管理（推荐）"></a><strong>（1）声明式事务管理（推荐）</strong></h3><p>基于 <code>@Transactional</code> 注解，最常见的事务管理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库操作，自动管理事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>代码清晰，解耦业务逻辑和事务管理。</li>
<li>由 <strong>AOP 代理</strong> 负责事务控制。</li>
</ul>
<h3 id="（2）编程式事务管理（灵活但不推荐）"><a href="#（2）编程式事务管理（灵活但不推荐）" class="headerlink" title="（2）编程式事务管理（灵活但不推荐）"></a><strong>（2）编程式事务管理（灵活但不推荐）</strong></h3><p>使用 <code>TransactionTemplate</code> 或 <code>PlatformTransactionManager</code> 手动控制事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>适用于复杂事务控制，如 <strong>多个数据源事务管理</strong>。</li>
<li>灵活，可以手动回滚事务。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码冗余，侵入业务逻辑，不符合 <strong>Spring AOP</strong> 设计原则。</li>
</ul>
<hr>
<h2 id="Spring-事务常见问题及解决方案"><a href="#Spring-事务常见问题及解决方案" class="headerlink" title="Spring 事务常见问题及解决方案"></a><strong>Spring 事务常见问题及解决方案</strong></h2><h3 id="（1）事务失效问题"><a href="#（1）事务失效问题" class="headerlink" title="（1）事务失效问题"></a><strong>（1）事务失效问题</strong></h3><p><strong>问题</strong>：</p>
<p><code>@Transactional</code> 失效的常见原因：</p>
<ol>
<li><strong>方法内部调用</strong>（<code>this.xxx()</code> 调用不会触发事务代理）</li>
<li><strong>非公共方法（<code>private</code>、<code>protected</code>）</strong> 不能被 Spring 代理拦截</li>
<li><strong>事务传播机制影响</strong>（如 <code>REQUIRES_NEW</code> 影响子事务）</li>
<li><strong>AOP 代理失效</strong>（未使用 <strong>Spring 容器管理的 Bean</strong>）</li>
</ol>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>确保 <code>@Transactional</code> 标注的方法是 <code>public</code></strong></li>
<li><strong>使用 <code>self</code> 调用</strong>（获取 <code>this</code> 的 Spring 代理对象）</li>
<li><strong>正确设置 <code>Propagation</code> 传播机制</strong></li>
</ul>
<hr>
<h3 id="（2）事务回滚问题"><a href="#（2）事务回滚问题" class="headerlink" title="（2）事务回滚问题"></a><strong>（2）事务回滚问题</strong></h3><p><strong>问题</strong>：</p>
<ul>
<li>Spring 只对 <strong><code>RuntimeException</code>（运行时异常）</strong> 回滚，而 <code>CheckedException</code>（受检异常）不会触发回滚。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>显式指定 <code>rollbackFor</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（3）多数据源事务问题"><a href="#（3）多数据源事务问题" class="headerlink" title="（3）多数据源事务问题"></a><strong>（3）多数据源事务问题</strong></h3><p><strong>问题</strong>：</p>
<ul>
<li>Spring 事务默认只能管理 <strong>单一数据源</strong>，如果涉及多个数据源，则事务无法正常回滚。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用 <strong>分布式事务管理框架</strong>（如 Seata、Atomikos）</li>
<li>Spring Boot 2.0+ 版本可使用 <code>@Transactional</code> + <code>@EnableTransactionManagement</code> 配合 <strong>JTA（Java Transaction API）</strong> 进行多数据源事务管理。</li>
</ul>
<hr>
<h3 id="（4）事务超时问题"><a href="#（4）事务超时问题" class="headerlink" title="（4）事务超时问题"></a><strong>（4）事务超时问题</strong></h3><p><strong>问题</strong>：</p>
<ul>
<li>事务长时间未提交，导致数据库锁等待，影响性能。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>设置 <strong>事务超时时间</strong>，避免长事务：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 5)</span> <span class="comment">// 超时 5 秒</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="五、Spring-MVC"><a href="#五、Spring-MVC" class="headerlink" title="五、Spring MVC"></a><strong>五、Spring MVC</strong></h1><h2 id="MVC开发"><a href="#MVC开发" class="headerlink" title="MVC开发"></a>MVC开发</h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。—-设计模式？or 软件设计规范？</p>
<h3 id="Model-1-时代"><a href="#Model-1-时代" class="headerlink" title="Model 1 时代"></a><strong>Model 1 时代</strong></h3><p>在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层（Controller）又是表现层（View）。</p>
<h3 id="Model-2-时代"><a href="#Model-2-时代" class="headerlink" title="Model 2 时代"></a><strong>Model 2 时代</strong></h3><p>Java Bean(Model)+ JSP（View）+Servlet（Controller）早期的 JavaWeb MVC 开发模式。—Struts2框架</p>
<ul>
<li>Model:系统涉及的数据，也就是 dao 和 bean。</li>
<li>View：展示模型中的数据，只是用来展示。</li>
<li>Controller：接受用户请求，并将请求发送至 Model，最后返回数据给 JSP 并展示给用户</li>
</ul>
<h3 id="Spring-MVC-时代"><a href="#Spring-MVC-时代" class="headerlink" title="Spring MVC 时代"></a><strong>Spring MVC 时代</strong></h3><p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)</p>
<h2 id="SpringMVC核心组件及工作原理简单介绍"><a href="#SpringMVC核心组件及工作原理简单介绍" class="headerlink" title="SpringMVC核心组件及工作原理简单介绍"></a>SpringMVC核心组件及工作原理简单介绍</h2><ul>
<li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户</li>
</ul>
<p><img src="attachment:1e5ec313-bf01-4da3-a1e0-e10b09d15c26:image.png" alt="image.png"></p>
<p>SpringMVC 的工作流程主要包括以下 6 个步骤：</p>
<ol>
<li><strong>请求进入</strong>：用户发送请求，前端控制器 <strong>DispatcherServlet</strong> 拦截请求。</li>
<li><strong>映射匹配</strong>：DispatcherServlet 通过 <strong>HandlerMapping</strong> 找到对应的处理器（Controller 方法）。</li>
<li><strong>执行处理器</strong>：调用 <strong>HandlerAdapter</strong> 执行 Controller 里的具体方法，返回 <strong>ModelAndView</strong>（数据+视图）。</li>
<li><strong>视图解析</strong>：<strong>ViewResolver</strong> 解析返回的视图名称，找到具体的视图（如 JSP、Thymeleaf）。</li>
<li><strong>视图渲染</strong>：视图模板引擎渲染数据，生成 HTML 页面。</li>
<li><strong>响应返回</strong>：最终的 HTML 页面返回给用户浏览器。</li>
</ol>
<p>简化流程：</p>
<p><strong>请求 → DispatcherServlet → HandlerMapping → Controller → ViewResolver → 视图渲染 → 响应</strong></p>
<h1 id="六、Spring-Security"><a href="#六、Spring-Security" class="headerlink" title="六、Spring Security"></a>六、Spring Security</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Spring Security 是一个用于 <strong>身份认证（Authentication）</strong> 和 <strong>授权（Authorization）</strong> 的安全框架，提供一整套安全机制，如 <strong>登录验证、权限管理、会话管理、CSRF 防护、OAuth2</strong> 等，广泛用于保护 <strong>Spring Boot</strong> 应用。</p>
<hr>
<h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a><strong>核心技术</strong></h3><ol>
<li><strong>认证（Authentication）</strong><ul>
<li>使用 <code>UserDetailsService</code> 进行用户信息查询</li>
<li>支持多种认证方式：用户名密码、OAuth2、JWT、LDAP、SSO</li>
<li>可自定义 <code>AuthenticationProvider</code> 进行自定义认证</li>
</ul>
</li>
<li><strong>授权（Authorization）</strong><ul>
<li>角色&#x2F;权限控制：基于 <code>@PreAuthorize</code>、<code>@Secured</code> 进行方法级别的授权</li>
<li>URL 级别授权：通过 <code>HttpSecurity</code> 配置请求访问权限</li>
<li>RBAC（基于角色访问控制）与 ACL（基于访问控制列表）</li>
</ul>
</li>
<li><strong>过滤器链（Filter Chain）</strong><ul>
<li>Spring Security 内部使用 <strong>Servlet 过滤器链</strong> 处理请求</li>
<li><code>SecurityFilterChain</code> 控制整个安全逻辑，包括认证、授权、CSRF 保护</li>
</ul>
</li>
<li><strong>会话管理（Session Management）</strong><ul>
<li>允许配置 <strong>用户会话并发控制</strong>，防止用户重复登录</li>
<li><strong>记住我（Remember-Me）</strong> 机制</li>
</ul>
</li>
<li><strong>CSRF 防护（Cross-Site Request Forgery）</strong><ul>
<li>Spring Security 默认开启 CSRF 保护，防止跨站请求伪造</li>
</ul>
</li>
<li><strong>OAuth2 &amp; JWT 支持</strong><ul>
<li>提供 OAuth2.0 认证与授权</li>
<li>结合 JWT 实现无状态认证，适用于微服务架构</li>
</ul>
</li>
</ol>
<hr>
<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a><strong>常见应用场景</strong></h3><ol>
<li><strong>企业级 Web 应用安全</strong><ul>
<li>保护企业管理系统（如 ERP、CRM）</li>
<li>角色&#x2F;权限分级访问控制</li>
</ul>
</li>
<li><strong>REST API 安全保护</strong><ul>
<li>结合 JWT 进行无状态认证</li>
<li>保护 API 免受未授权访问</li>
</ul>
</li>
<li><strong>单点登录（SSO）</strong><ul>
<li>结合 OAuth2 &#x2F; OpenID Connect 实现 SSO</li>
<li>适用于微服务架构</li>
</ul>
</li>
<li><strong>微服务安全</strong><ul>
<li>与 Spring Cloud Security 结合，确保微服务通信安全</li>
<li>通过 OAuth2 进行服务间认证</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Spring-Security-相关的类似技术"><a href="#Spring-Security-相关的类似技术" class="headerlink" title="Spring Security 相关的类似技术"></a><strong>Spring Security 相关的类似技术</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>主要特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Apache Shiro</strong></td>
<td>轻量级认证和授权框架，支持加密、会话管理</td>
<td>适用于小型 Web 项目</td>
</tr>
<tr>
<td><strong>Keycloak</strong></td>
<td>开源 IAM 解决方案，支持 OAuth2、SSO、LDAP</td>
<td>适用于企业级用户管理</td>
</tr>
<tr>
<td><strong>OAuth2 &#x2F; OpenID Connect</strong></td>
<td>标准协议，提供授权与身份认证</td>
<td>适用于分布式系统和 SSO</td>
</tr>
<tr>
<td><strong>JWT（JSON Web Token）</strong></td>
<td>轻量级 Token 机制，适合无状态认证</td>
<td>RESTful API 安全</td>
</tr>
</tbody></table>
<hr>
<h1 id="七、Spring-Data-JPA"><a href="#七、Spring-Data-JPA" class="headerlink" title="七、Spring Data JPA"></a>七、Spring Data JPA</h1><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Spring Data JPA 是 <strong>Spring 对 JPA（Java Persistence API）</strong> 的封装，提供了 <strong>简化数据库访问</strong> 的方式，使开发者不需要手写大量 SQL 或者实现 DAO 层，而是直接使用 <strong>接口</strong> 进行数据操作。</p>
<hr>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h2><ol>
<li><p><strong>简化 CRUD 操作</strong>：</p>
<p> 通过 <code>JpaRepository</code> 或 <code>CrudRepository</code>，无需手写 SQL，即可完成基本数据库操作。</p>
</li>
<li><p><strong>方法命名查询（Query Method）</strong>：</p>
<p> 通过方法命名规则自动生成 SQL，如：</p>
</li>
<li><p><strong>自定义 JPQL 或原生 SQL 查询</strong>：</p>
</li>
<li><p><strong>分页与排序支持</strong>：</p>
</li>
<li><p><strong>动态查询（Specifications）</strong>：</p>
<p> 可结合 <strong>Criteria API</strong> 实现动态条件查询。</p>
</li>
<li><p><strong>乐观锁&#x2F;悲观锁</strong>：</p>
</li>
</ol>
<hr>
<h2 id="常见应用场景-1"><a href="#常见应用场景-1" class="headerlink" title="常见应用场景"></a><strong>常见应用场景</strong></h2><p>Spring Data JPA 主要适用于 <strong>关系型数据库</strong>（如 MySQL、PostgreSQL）场景：</p>
<ol>
<li><strong>企业级应用</strong>（如 <strong>电商、CMS、ERP</strong> 等）</li>
<li><strong>RESTful API 后端服务</strong>（简化数据库访问逻辑）</li>
<li><strong>微服务架构中的数据层</strong>（可结合 Spring Cloud 使用）</li>
<li><strong>数据分析系统</strong>（支持复杂查询、分页等功能）</li>
</ol>
<hr>
<h2 id="其他相似的技术"><a href="#其他相似的技术" class="headerlink" title="其他相似的技术"></a><strong>其他相似的技术</strong></h2><table>
<thead>
<tr>
<th><strong>技术</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MyBatis（重点）</strong></td>
<td>轻量级 ORM，SQL 可控</td>
<td>复杂 SQL 需求，性能优化</td>
</tr>
<tr>
<td><strong>JPA（原生）</strong></td>
<td>需要手动编写 EntityManager</td>
<td>灵活管理事务和查询</td>
</tr>
<tr>
<td><strong>Hibernate</strong></td>
<td>JPA 的实现，提供更多扩展功能</td>
<td>适合大型应用</td>
</tr>
<tr>
<td><strong>Spring JDBC</strong></td>
<td>直接操作数据库，手写 SQL</td>
<td>高性能需求，避免 ORM 开销</td>
</tr>
</tbody></table>
<h2 id="Spring-Data-JPA-与-MyBatis-的区别"><a href="#Spring-Data-JPA-与-MyBatis-的区别" class="headerlink" title="Spring Data JPA 与 MyBatis 的区别"></a><strong>Spring Data JPA 与 MyBatis 的区别</strong></h2><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Spring Data JPA</strong></th>
<th><strong>MyBatis</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>查询方式</strong></td>
<td><strong>自动生成 SQL</strong>，可使用 JPQL&#x2F;原生 SQL</td>
<td><strong>手写 SQL</strong>，自定义 XML&#x2F;注解</td>
</tr>
<tr>
<td><strong>学习成本</strong></td>
<td><strong>低</strong>，无需关注 SQL 细节</td>
<td><strong>相对高</strong>，需要掌握 SQL</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>适用于 <strong>CRUD 频繁</strong> 的业务</td>
<td>适用于 <strong>复杂 SQL、性能优化</strong></td>
</tr>
<tr>
<td><strong>事务支持</strong></td>
<td>基于 <strong>Spring 事务管理</strong></td>
<td>需要手动配置事务</td>
</tr>
<tr>
<td><strong>开发效率</strong></td>
<td><strong>高</strong>，少量代码即可实现 CRUD</td>
<td><strong>低</strong>，需手写 SQL</td>
</tr>
<tr>
<td><strong>动态查询</strong></td>
<td><strong>支持 Criteria API</strong></td>
<td><strong>使用 XML 或动态 SQL</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>标准化的 CRUD 业务</strong></td>
<td><strong>复杂 SQL 查询、性能优化需求</strong></td>
</tr>
</tbody></table>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>Spring Data JPA</strong> 适用于 <strong>CRUD 业务多、SQL 复杂度低</strong> 的项目，开发速度快。</li>
<li><strong>MyBatis</strong> 适用于 <strong>需要精细控制 SQL、复杂查询优化</strong> 的项目，如 <strong>大数据量、复杂业务系统</strong>。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/02/27/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/03/02/SpringBoot/" rel="next" title="SpringBoot">
                  SpringBoot <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Merak Chan</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
